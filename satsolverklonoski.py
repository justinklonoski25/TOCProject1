# -*- coding: utf-8 -*-
"""SATSolverKlonoski.ipynb

Automatically generated by Colab.
"""

# Importing necessary libraries
import matplotlib.pyplot as plt
import sys
import pandas as pd
import time
import csv
import random
import matplotlib
matplotlib.use('Agg')  # Use the Agg backend (non-graphical) for matplotlib

# Function to check if a clause is satisfied by a given variable assignment
def clause_satisfied(clause, variable_assignment):
    for term in clause:
        var, is_negated = abs(term), term < 0
        if (is_negated and not variable_assignment[var]) or (not is_negated and variable_assignment[var]):
            return True
    return False

# Function to solve k-SAT problem using backtracking
def solve_ksat(total_vars, total_clauses, max_literals, cnf_wff):
    # Extract all clauses from the CNF formula (cnf_wff)
    all_clauses = cnf_wff[3:]
    # Initialize all variables as False
    var_assignment = [False] * total_vars

    # Recursive function for backtracking solver
    def backtrack_solver(current_index):
        # Base case: all variables have been assigned
        if current_index == total_vars:
            # Check if all clauses are satisfied
            for clause in all_clauses:
                clause_is_satisfied = False
                for term in clause:
                    var = abs(term)
                    truth_value = var_assignment[var - 1]
                    if term < 0:
                        truth_value = not truth_value
                    if truth_value:
                        clause_is_satisfied = True
                        break
                # If any clause is unsatisfied, return False
                if not clause_is_satisfied:
                    return False
            return True
        else:
            # Try setting the current variable to True
            var_assignment[current_index] = True
            if backtrack_solver(current_index + 1):
                return True
            # Try setting the current variable to False
            var_assignment[current_index] = False
            if backtrack_solver(current_index + 1):
                return True
        return False

    # Start backtracking solver from the first variable
    found_solution = backtrack_solver(0)
    if found_solution:
        # Return True with the final variable assignment
        return True, [i + 1 if var_assignment[i] else -(i + 1) for i in range(total_vars)]
    else:
        # Return False if no solution is found
        return False, []

# Function to solve 2-SAT problem using random assignments and flipping
def solve_2sat(total_vars, total_clauses, max_literals, cnf_wff):
    # Generate a random variable assignment
    def random_var_assignment(var_count):
        return [random.choice([True, False]) for _ in range(var_count)]

    # Function to evaluate a clause with a given variable assignment
    def clause_evaluation(clause, var_assignment):
        return any((var_assignment[abs(term) - 1] if term > 0 else not var_assignment[abs(term) - 1]) for term in clause)

    # Function to check if all clauses are satisfied
    def check_satisfiability(var_assignment):
        return all(clause_evaluation(clause, var_assignment) for clause in cnf_wff[3:])

    max_attempts = 2 * total_vars ** 2  # Max attempts for random assignments
    for _ in range(max_attempts):
        var_assignment = random_var_assignment(total_vars)
        for _ in range(2 * total_vars ** 2):
            # Find clauses that are not satisfied
            unsatisfied_clauses = [clause for clause in cnf_wff[3:] if not clause_evaluation(clause, var_assignment)]
            if not unsatisfied_clauses:
                # Return True with satisfying variable assignment
                return True, [(i + 1) if var_assignment[i] else -(i + 1) for i in range(total_vars)]
            # Randomly pick an unsatisfied clause and flip a variable in it
            chosen_clause = random.choice(unsatisfied_clauses)
            chosen_literal = random.choice(chosen_clause)
            var_index = abs(chosen_literal) - 1
            var_assignment[var_index] = not var_assignment[var_index]

    return False, []

# Function to decide whether to use 2-SAT or k-SAT solving method
def solve_sat_problem(var_count, clause_count, max_literals, cnf_wff):
    if var_count == 2:
        return solve_2sat(var_count, clause_count, max_literals, cnf_wff)
    else:
        return solve_ksat(var_count, clause_count, max_literals, cnf_wff)

# Function to verify if a given variable assignment satisfies all clauses
def verify_assignment(cnf_wff, var_assignment):
    clauses = cnf_wff[3:]
    for clause in clauses:
        satisfied = False
        for term in clause:
            var = abs(term)
            if var <= len(var_assignment):
                value = var_assignment[var - 1]
                if term < 0:
                    value = not value
                if value:
                    satisfied = True
                    break
            else:
                return False
        if not satisfied:
            return False
    return True

# Function to read a CNF file in DIMACS format
def read_cnf_file(filepath):
    wffs = []
    current_wff = []
    var_count = None
    clause_count = None
    max_literals = None

    with open(filepath, "r") as file:
        lines = file.readlines()
        for line in lines:
            elements = line.strip().split(",")
            # Read comments (lines starting with 'c') and extract variable and clause count
            if line.startswith("c"):
                if len(elements) >= 4:
                    var_count = int(elements[1])
                    clause_count = int(elements[2])
                    if len(elements) > 4:
                        answer = elements[3]
                        current_wff.append(answer)
            # Read problem definition line (starting with 'p cnf')
            elif line.startswith("p cnf"):
                if current_wff:
                    wffs.append((var_count, clause_count, max_literals, current_wff))
                current_wff = []
                elements = line.split()
                if len(elements) == 4 and elements[1] == "cnf":
                    var_count, clause_count = int(elements[2]), int(elements[3])
            # Read clauses (each clause is a list of literals)
            elif line.strip() and var_count is not None and clause_count is not None:
                literals = [int(literal) for literal in elements if literal != "0"]
                current_wff.append(literals)
                if [0] in current_wff:
                    max_clauses = len(current_wff) - 1
                    if max_literals is None or len(literals) > max_literals:
                        max_literals = len(literals)
                    current_wff[0] = max_clauses

    return wffs

# Function to save results to a CSV file
def save_results_to_csv(results, output_filename, wff_length, input_filename):
    with open(output_filename, 'w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(["Problem Number, Number of Variables, Number of Clauses, Maximum Number of Literals (k), Total Number of Literals, S/U, Test Code Answer, Execution Time (Î¼s), Assignment"])
        for result in results:
            writer.writerow(result)

# Main function to process the input file and solve the SAT problems
def main(input_filepath):
    cnf_wffs = read_cnf_file(input_filepath)
    if not cnf_wffs:
        print("File not found")
        sys.exit(1)

    results = []
    satisfiable_times = []
    unsatisfiable_times = []
    satisfiable_vars = []
    unsatisfiable_vars = []

    # Iterate over each CNF formula (WFF) in the input file
    for i, (var_count, clause_count, max_literals, wff) in enumerate(cnf_wffs, start=1):
        start_time = time.time()
        # Solve the SAT problem and measure execution time
        satisfiable, assignment = solve_sat_problem(var_count, clause_count, max_literals, wff)
        execution_time = round((time.time() - start_time) * 1e6, 2)

        # Store results including execution time and satisfiability
        result_data = [i, var_count, clause_count, len(wff) - 3, "S" if satisfiable else "U", 1 if verify_assignment(wff, assignment) else -1, execution_time]
        result_data.extend(assignment[1:])
        results.append(result_data)

        # Categorize execution time based on satisfiability
        if wff[2] == "S":
            satisfiable_times.append(execution_time)
            satisfiable_vars.append(var_count)
        else:
            unsatisfiable_times.append(execution_time)
            unsatisfiable_vars.append(var_count)

    # Save results to an output CSV file
    output_file = "output.csv"
    save_results_to_csv(results, output_file, len(wff), input_filepath)

    # Plot execution time vs. number of variables
    plt.figure(figsize=(10, 10))
    plt.scatter(satisfiable_vars, satisfiable_times, c='green', label='Satisfiable')
    plt.scatter(unsatisfiable_vars, unsatisfiable_times, c='red', label='Unsatisfiable')
    plt.xlabel('Number of Variables')
    plt.ylabel('Execution Time (microseconds)')
    plt.title('Execution Time vs. Number of Variables')
    plt.legend()
    plt.grid(True)
    plt.savefig('scatter_plot.png')
    plt.show()

# Entry point for the script
if __name__ == "__main__":
    # Ensure the correct number of command-line arguments is provided
    if len(sys.argv) != 2:
        print("Usage: python solver.py <input_file>")
        sys.exit(1)

