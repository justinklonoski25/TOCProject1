# -*- coding: utf-8 -*-
"""SATSolverKlonoski.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ppVJBPOalnu-d2flqPyOknRbzBxz2dPc
"""

import matplotlib.pyplot as plt
import sys
import pandas as pd
import time
import csv
import random
import matplotlib
matplotlib.use('Agg')  # Use the Agg backend (non-graphical)

def clause_satisfied(clause, variable_assignment):
    for term in clause:
        var, is_negated = abs(term), term < 0
        if (is_negated and not variable_assignment[var]) or (not is_negated and variable_assignment[var]):
            return True
    return False

def solve_ksat(total_vars, total_clauses, max_literals, cnf_wff):
    all_clauses = cnf_wff[3:]
    var_assignment = [False] * total_vars

    def backtrack_solver(current_index):
        if current_index == total_vars:
            for clause in all_clauses:
                clause_is_satisfied = False
                for term in clause:
                    var = abs(term)
                    truth_value = var_assignment[var - 1]
                    if term < 0:
                        truth_value = not truth_value
                    if truth_value:
                        clause_is_satisfied = True
                        break
                if not clause_is_satisfied:
                    return False
            return True
        else:
            var_assignment[current_index] = True
            if backtrack_solver(current_index + 1):
                return True
            var_assignment[current_index] = False
            if backtrack_solver(current_index + 1):
                return True
        return False

    found_solution = backtrack_solver(0)
    if found_solution:
        return True, [i + 1 if var_assignment[i] else -(i + 1) for i in range(total_vars)]
    else:
        return False, []

def solve_2sat(total_vars, total_clauses, max_literals, cnf_wff):
    def random_var_assignment(var_count):
        return [random.choice([True, False]) for _ in range(var_count)]

    def clause_evaluation(clause, var_assignment):
        return any((var_assignment[abs(term) - 1] if term > 0 else not var_assignment[abs(term) - 1]) for term in clause)

    def check_satisfiability(var_assignment):
        return all(clause_evaluation(clause, var_assignment) for clause in cnf_wff[3:])

    max_attempts = 2 * total_vars ** 2
    for _ in range(max_attempts):
        var_assignment = random_var_assignment(total_vars)
        for _ in range(2 * total_vars ** 2):
            unsatisfied_clauses = [clause for clause in cnf_wff[3:] if not clause_evaluation(clause, var_assignment)]
            if not unsatisfied_clauses:
                return True, [(i + 1) if var_assignment[i] else -(i + 1) for i in range(total_vars)]
            chosen_clause = random.choice(unsatisfied_clauses)
            chosen_literal = random.choice(chosen_clause)
            var_index = abs(chosen_literal) - 1
            var_assignment[var_index] = not var_assignment[var_index]

    return False, []

def solve_sat_problem(var_count, clause_count, max_literals, cnf_wff):
    if var_count == 2:
        return solve_2sat(var_count, clause_count, max_literals, cnf_wff)
    else:
        return solve_ksat(var_count, clause_count, max_literals, cnf_wff)

def verify_assignment(cnf_wff, var_assignment):
    clauses = cnf_wff[3:]
    for clause in clauses:
        satisfied = False
        for term in clause:
            var = abs(term)
            if var <= len(var_assignment):
                value = var_assignment[var - 1]
                if term < 0:
                    value = not value
                if value:
                    satisfied = True
                    break
            else:
                return False
        if not satisfied:
            return False
    return True

def read_cnf_file(filepath):
    wffs = []
    current_wff = []
    var_count = None
    clause_count = None
    max_literals = None

    with open(filepath, "r") as file:
        lines = file.readlines()
        for line in lines:
            elements = line.strip().split(",")
            if line.startswith("c"):
                if len(elements) >= 4:
                    var_count = int(elements[1])
                    clause_count = int(elements[2])
                    if len(elements) > 4:
                        answer = elements[3]
                        current_wff.append(answer)
            elif line.startswith("p cnf"):
                if current_wff:
                    wffs.append((var_count, clause_count, max_literals, current_wff))
                current_wff = []
                elements = line.split()
                if len(elements) == 4 and elements[1] == "cnf":
                    var_count, clause_count = int(elements[2]), int(elements[3])
            elif line.strip() and var_count is not None and clause_count is not None:
                literals = [int(literal) for literal in elements if literal != "0"]
                current_wff.append(literals)
                if [0] in current_wff:
                    max_clauses = len(current_wff) - 1
                    if max_literals is None or len(literals) > max_literals:
                        max_literals = len(literals)
                    current_wff[0] = max_clauses

    return wffs

def save_results_to_csv(results, output_filename, wff_length, input_filename):
    with open(output_filename, 'w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(["Problem Number, Number of Variables, Number of Clauses, Maximum Number of Literals (k), Total Number of Literals, S/U, Test Code Answer, Execution Time (Î¼s), Assignment"])
        for result in results:
            writer.writerow(result)

def main(input_filepath):
    cnf_wffs = read_cnf_file(input_filepath)
    if not cnf_wffs:
        print("File not found")
        sys.exit(1)

    results = []
    satisfiable_times = []
    unsatisfiable_times = []
    satisfiable_vars = []
    unsatisfiable_vars = []

    for i, (var_count, clause_count, max_literals, wff) in enumerate(cnf_wffs, start=1):
        start_time = time.time()
        satisfiable, assignment = solve_sat_problem(var_count, clause_count, max_literals, wff)
        execution_time = round((time.time() - start_time) * 1e6, 2)

        result_data = [i, var_count, clause_count, len(wff) - 3, "S" if satisfiable else "U", 1 if verify_assignment(wff, assignment) else -1, execution_time]
        result_data.extend(assignment[1:])
        results.append(result_data)

        if wff[2] == "S":
            satisfiable_times.append(execution_time)
            satisfiable_vars.append(var_count)
        else:
            unsatisfiable_times.append(execution_time)
            unsatisfiable_vars.append(var_count)

    output_file = "output.csv"
    save_results_to_csv(results, output_file, len(wff), input_filepath)

    with open(output_file, 'r') as f:
        next(f)
        for line in f:
            if line.startswith("kSAT"):
                break

    plt.figure(figsize=(10, 10))
    plt.scatter(satisfiable_vars, satisfiable_times, c='green', label='Satisfiable')
    plt.scatter(unsatisfiable_vars, unsatisfiable_times, c='red', label='Unsatisfiable')
    plt.xlabel('Number of Variables')
    plt.ylabel('Execution Time (microseconds)')
    plt.title('Execution Time vs. Number of Variables')
    plt.legend()
    plt.grid(True)
    plt.savefig('scatter_plot.png')
    plt.show()

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python solver.py <input_file>")
        sys.exit(1)

    input_filepath = sys.argv[1]
    main(input_filepath)